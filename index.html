<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Interactive Map — Final (Circle Filter + Global Search)</title>

<!-- Favicon placeholder -->
<link rel="icon" href="data:,">

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- MarkerCluster -->
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<!-- PapaParse -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

<style>
  :root { --blue:#1d4ed8; --muted:#94a3b8; --green:#16a34a; --red:#dc2626; --bg:#ffffff; }
  html,body{height:100%;margin:0;font-family:Inter,Arial,sans-serif;background:var(--bg)}
  #map{position:absolute;inset:0}

  /* top center global search */
  #globalSearchWrap{position:absolute;top:12px;left:50%;transform:translateX(-50%);z-index:8000;display:flex;gap:8px;align-items:center}
  #globalSearch{width:520px;padding:10px 14px;border-radius:24px;border:1px solid #cbd5e1;box-shadow:0 6px 20px rgba(2,6,23,0.08);font-size:15px}
  #globalSearchBtn{padding:10px 14px;border-radius:20px;border:none;background:var(--blue);color:#fff;cursor:pointer}
  .autocomplete-list { position:absolute; background:white; border:1px solid #e2e8f0; max-height:200px; overflow:auto; z-index:9000; border-radius:6px; box-shadow:0 6px 20px rgba(2,6,23,0.08); width:520px; margin-top:44px; left:50%; transform:translateX(-50%); }
  .autocomplete-item { padding:8px 10px; cursor:pointer; border-bottom:1px solid #f1f5f9; font-size:13px; }
  .autocomplete-item:hover { background:#f1f5f9; }

  /* right controls */
  .panel{position:absolute;top:80px;right:12px;z-index:7800;width:360px;background:rgba(255,255,255,0.98);padding:12px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.12)}
  .panel h3{margin:0 0 8px 0;font-size:16px}
  #siteSearch{width:100%;padding:8px;border-radius:8px;border:1px solid #e6eef8;margin-bottom:8px}
  #siteSuggest { position: absolute; right: 12px; top: 138px; width: 360px; z-index:9001; background:white; border:1px solid #e2e8f0; max-height:180px; overflow:auto; border-radius:6px; box-shadow:0 6px 20px rgba(2,6,23,0.08); display:none; }
  .site-item { padding:8px 10px; border-bottom:1px solid #f1f5f9; cursor:pointer; }
  .site-item:hover { background:#f1f5f9; }
  .slider-row{display:flex;align-items:center;gap:8px;margin-bottom:8px}
  .slider-row label{min-width:64px;font-size:13px}
  #circleFilterBox{max-height:180px;overflow:auto;border:1px solid #eef2ff;padding:8px;border-radius:8px;background:#fff}
  .control-row{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  button.btn{padding:8px 10px;border-radius:8px;border:none;background:var(--blue);color:#fff;cursor:pointer}
  button.ghost{background:#f1f5f9;color:#0f172a;border:1px solid #e2e8f0}
  .hint{font-size:12px;color:#64748b;margin-top:6px}
  .distance-label{font-size:12px;padding:3px 6px;background:white;border:1px solid #333;border-radius:4px}
  /* cluster styles */
  .marker-cluster-small { background-color: rgba(29,78,216,0.8) }
  .marker-cluster { color: white }

  /* small upload area inside control panel */
  #uploadRow { margin-bottom:10px; display:flex; gap:6px; align-items:center; }
  #csvUpload { padding:6px; }
</style>
</head>
<body>

<!-- Global place search -->
<div id="globalSearchWrap">
  <input id="globalSearch" placeholder="Search any place worldwide (city, address, landmark) — press Enter or click Go" autocomplete="off" />
  <button id="globalSearchBtn">Go</button>
</div>
<!-- autocomplete list for place -->
<div id="placeSuggestList" class="autocomplete-list" style="display:none;"></div>

<!-- Controls panel -->
<div class="panel" id="controlPanel">
  <h3>Controls</h3>

  <!-- Upload (new) -->
  <div id="uploadRow">
    <label style="font-weight:600">Upload CSV</label>
    <input type="file" id="csvUpload" accept=".csv" />
    <button class="ghost" id="loadDefaultBtn" title="Load default asm.csv (if present)">Load default</button>
  </div>

  <input id="siteSearch" placeholder="Search site name or number (type + Enter)" autocomplete="off" />
  <div id="siteSuggest"></div>

  <div class="slider-row">
    <label>Radius</label>
    <input id="radiusSlider" type="range" min="0" max="5000" step="10" value="1000" />
    <div id="radiusValue" style="min-width:80px;text-align:right;font-weight:600">1000 m</div>
  </div>

  <div style="font-size:13px;margin-bottom:6px"><strong>Circle filter</strong><div class="hint">Select circles — only selected circles' sites are shown. Unchecking ALL hides all.</div></div>
  <div id="circleFilterBox"></div>

  <div class="control-row">
    <button class="btn" id="selectAllBtn">Select All</button>
    <button class="btn ghost" id="clearAllBtn">Clear All</button>
    <button class="btn" id="exportBtn">Export Visible</button>
  </div>
</div>

<div id="map"></div>

<script>
/* ================= CONFIG ================= */
const CSV_FILE = 'asm.csv'; // fallback if user doesn't upload
const INITIAL_CENTER = [28.55,77.24];
const INITIAL_ZOOM = 11;

/* ================= STATE ================= */
let map;
let siteData = []; // raw
let markers = {}; // nameLower => { site, marker }
let markerCluster; // MarkerClusterGroup
let selectedCircles = new Set(); // set of selected circles (not including 'ALL')
let linesLayer;
let placeMarker = null;
let activeCenter = null;

// new: click marker used for map clicks
let clickMarker = null;

/* ================ INIT MAP ================ */
function initMap(){
  map = L.map('map', { center: INITIAL_CENTER, zoom: INITIAL_ZOOM, preferCanvas: true });

  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OpenStreetMap' });
  const esri = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 19, attribution: 'Tiles © Esri' });

  osm.addTo(map);
  L.control.layers({ "Normal": osm, "Satellite": esri }, {}, { collapsed: false }).addTo(map);

  markerCluster = L.markerClusterGroup({ chunkedLoading: true, chunkProgress: () => {} });
  map.addLayer(markerCluster);

  linesLayer = L.layerGroup().addTo(map);

  // Map click -> treat as place search (Option B simplified): reset highlights and show lines + popup
  map.on('click', async (ev) => {
    try {
      // Ignore clicks on marker icons or interactive overlays
      if (ev.originalEvent && ev.originalEvent.target) {
        const t = ev.originalEvent.target;
        if (t.closest && (t.closest('.leaflet-marker-icon') || t.closest('.leaflet-interactive'))) {
          return; // clicked on a marker; normal marker click will handle it
        }
      }

      const lat = ev.latlng.lat;
      const lon = ev.latlng.lng;

      // Remove previous clickMarker if exists
      if (clickMarker) {
        try { map.removeLayer(clickMarker); } catch(e) {}
        clickMarker = null;
      }

      // Place a temporary marker at clicked point (red pin)
      clickMarker = L.marker([lat, lon], { title: 'Clicked location' }).addTo(map);

      // Reverse geocode (best effort) to get human-readable name
      let displayName = null;
      try {
        const resp = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&zoom=16&addressdetails=0`);
        if (resp && resp.ok) {
          const j = await resp.json();
          if (j && j.display_name) displayName = j.display_name;
        }
      } catch (err) {
        console.warn('Reverse geocode failed', err);
      }

      // Use existing function to highlight nearby (it clears linesLayer and resets markers)
      // highlightNearbyAt will draw polylines, set icons for nearby, and open a popup at the point
      highlightNearbyAt(lat, lon, displayName ? displayName : `Lat:${lat.toFixed(6)}, Lng:${lon.toFixed(6)}`);

      // ensure clickMarker popup is replaced by highlightNearbyAt's popup (highlightNearbyAt opens popup)
      // but keep clickMarker for potential later removal or icon
    } catch (err) {
      console.error('Map click handler error', err);
    }
  });
}

/* ================ HELPERS ================ */
function safeId(text){ return (text||'').toString().replace(/\s+/g,'_').replace(/[^\w\-]/g,''); }
function defaultColor(){ return '#1d4ed8'; }
function distMeters(lat1, lon1, lat2, lon2){
  const R = 6371000; const toRad = x => x * Math.PI/180;
  const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

/* ================ CSV LOAD (PapaParse) — accepts event or fallback ================ */
function loadCsv(event){
  const file = event && event.target && event.target.files ? event.target.files[0] : null;

  const parseAndBuild = (rows) => {
    siteData = rows.map(r => ({
      name: (r.name ?? '').toString(),
      lat: parseFloat(r.lat),
      lng: parseFloat(r.lng),
      density: (r.density ?? '').toString(),
      circle: (r.circle ?? '').toString()
    })).filter(s => s.name && !Number.isNaN(s.lat) && !Number.isNaN(s.lng));

    if (!siteData.length) {
      alert('No valid rows found. CSV header must be: name,lat,lng,density,circle');
      return;
    }

    buildCircleFilterUI();
    createMarkers();
    buildSiteIndexForAutocomplete();
  };

  if (file) {
    Papa.parse(file, {
      header: true, skipEmptyLines: true, transformHeader: h => h.trim(),
      complete: (res) => { parseAndBuild(res.data); },
      error: (err) => { console.error('CSV parse error', err); alert('Failed to load CSV: ' + (err && err.message ? err.message : err)); }
    });
  } else {
    Papa.parse(CSV_FILE, {
      download: true, header: true, skipEmptyLines: true, transformHeader: h => h.trim(),
      chunkSize: 1024*1024,
      complete: (res) => { parseAndBuild(res.data); },
      error: (err) => { console.warn('Default CSV not found or failed to load, user must upload a file to populate data.', err); }
    });
  }
}

/* ================ Circle Filter UI ================ */
function buildCircleFilterUI(){
  const box = document.getElementById('circleFilterBox');
  box.innerHTML = '';

  const uniq = Array.from(new Set(siteData.map(s => s.circle))).filter(x => x && x.trim().length).sort();

  const allDiv = document.createElement('div'); allDiv.innerHTML = `<label><input id="allCircles" type="checkbox" checked> <strong>All</strong></label><hr>`;
  box.appendChild(allDiv);
  document.getElementById('allCircles').addEventListener('change', (e) => {
    const checked = e.target.checked;
    uniq.forEach(c => { const el = document.getElementById('chk_'+safeId(c)); if (el) el.checked = checked; });
    syncSelectedCircles();
  });

  uniq.forEach(c => {
    const id = 'chk_' + safeId(c);
    const row = document.createElement('div'); row.style.marginBottom = '6px';
    row.innerHTML = `<label><input id="${id}" type="checkbox" data-circle="${c}" checked> ${c}</label>`;
    box.appendChild(row);
    document.getElementById(id).addEventListener('change', () => {
      const allChecked = uniq.every(cc => { const el = document.getElementById('chk_'+safeId(cc)); return el && el.checked; });
      const allCb = document.getElementById('allCircles'); if (allCb) allCb.checked = allChecked;
      syncSelectedCircles();
    });
  });

  selectedCircles.clear();
  uniq.forEach(c => selectedCircles.add(c));
}

/* sync selectedCircles based on UI, and update markers visibility */
function syncSelectedCircles(){
  selectedCircles.clear();
  document.querySelectorAll('#circleFilterBox input[type=checkbox][data-circle]').forEach(cb => {
    if (cb.checked) selectedCircles.add(cb.dataset.circle);
  });
  updateVisibleMarkers();
}

/* ================ Create markers & manage visibility ================ */
function createMarkers(){
  markerCluster.clearLayers();
  markers = {};

  siteData.forEach(s => {
    const icon = createDotIcon(defaultColor());
    const m = L.marker([s.lat, s.lng], { icon: icon, title: s.name });
    m.bindTooltip(`<strong>${s.name}</strong>`, { direction: 'top' });
    m.on('click', () => { showSitePopupAndHighlight(s, m); });
    markers[s.name.toLowerCase()] = { site: s, marker: m };
  });

  updateVisibleMarkers();
}

/* helper to create small colored dot as DivIcon */
function createDotIcon(color){
  const html = `<div style="width:14px;height:14px;border-radius:50%;background:${color};box-shadow:0 2px 4px rgba(0,0,0,0.3)"></div>`;
  return L.divIcon({ html, className: '', iconSize: [14,14], iconAnchor: [7,7] });
}

/* add/remove markers from cluster based on selectedCircles / ALL state */
function updateVisibleMarkers(){
  const allChecked = document.getElementById('allCircles') ? document.getElementById('allCircles').checked : false;
  const anyIndividualChecked = document.querySelectorAll('#circleFilterBox input[type=checkbox][data-circle]:checked').length > 0;
  markerCluster.clearLayers();

  Object.values(markers).forEach(obj => {
    const c = obj.site.circle;
    const show = allChecked ? true : (anyIndividualChecked ? document.querySelector(`#circleFilterBox input[data-circle="${c}"]`) && document.querySelector(`#circleFilterBox input[data-circle="${c}"]`).checked : false);
    if (show) {
      obj.marker.setIcon(createDotIcon(defaultColor()));
      markerCluster.addLayer(obj.marker);
    }
  });
}

/* ================ Popup + Highlight logic (click on site) ================ */
function showSitePopupAndHighlight(site, marker){
  linesLayer.clearLayers();
  activeCenter = site;

  const allChecked = document.getElementById('allCircles') ? document.getElementById('allCircles').checked : false;
  const visibleCirclesCount = document.querySelectorAll('#circleFilterBox input[type=checkbox][data-circle]:checked').length;

  const visibleFunc = (s) => {
    if (allChecked) return true;
    if (visibleCirclesCount === 0) return false;
    const el = document.querySelector(`#circleFilterBox input[data-circle="${s.circle}"]`);
    return el && el.checked;
  };

  const R = Number(document.getElementById('radiusSlider').value || 1000);
  document.getElementById('radiusValue').textContent = R + ' m';

  const nearby = [];
  siteData.forEach(s => {
    if (!visibleFunc(s)) return;
    if (s.name === site.name) return;
    const d = distMeters(site.lat, site.lng, s.lat, s.lng);
    if (d <= R) nearby.push({ site: s, dist: Math.round(d) });
  });

  Object.values(markers).forEach(obj => {
    const isVisible = (allChecked) ? true : (visibleCirclesCount === 0 ? false : (document.querySelector(`#circleFilterBox input[data-circle="${obj.site.circle}"]`) && document.querySelector(`#circleFilterBox input[data-circle="${obj.site.circle}"]`).checked));
    if (!isVisible) return;
    if (obj.site.name === site.name) {
      obj.marker.setIcon(createDotIcon('#dc2626'));
    } else {
      const found = nearby.find(n => n.site.name.toLowerCase() === obj.site.name.toLowerCase());
      if (found) obj.marker.setIcon(createDotIcon('#16a34a'));
      else obj.marker.setIcon(createDotIcon(defaultColor()));
    }
  });

  nearby.forEach(n => {
    L.polyline([[site.lat, site.lng], [n.site.lat, n.site.lng]], { color: '#ff7f50', weight: 2, opacity: 0.95 }).addTo(linesLayer);
    const midLat = (site.lat + n.site.lat)/2;
    const midLng = (site.lng + n.site.lng)/2;
    L.marker([midLat, midLng], { icon: L.divIcon({ className:'distance-label', html:`${Math.round(n.dist)} m`, iconSize:[80,20] }) }).addTo(linesLayer);
  });

  const count = nearby.length;
  let listHtml = '<div style="max-height:200px;overflow:auto;">';
  if (count === 0) listHtml += `<i>No sites within ${R} m</i>`;
  else listHtml += nearby.map(n => `${n.site.name} — ${(n.dist/1000).toFixed(3)} km — density: ${n.site.density || 'N/A'}`).join('<br>');
  listHtml += '</div>';

  const popupHtml = `<div style="min-width:300px">
    <strong>${site.name}</strong><br/>
    Lat: ${site.lat.toFixed(5)} &nbsp; Lng: ${site.lng.toFixed(5)}<br/>
    Density: ${site.density || 'N/A'}<br/>
    Circle: ${site.circle || 'N/A'}<br/>
    <b>Count within ${R} m:</b> ${count}
    <hr/>
    ${listHtml}
    <div style="margin-top:8px"><button id="exportNearbyBtn" style="padding:8px 10px;border-radius:6px;border:none;background:#0b69ff;color:#fff;cursor:pointer">Export Nearby</button></div>
  </div>`;

  marker.bindPopup(popupHtml).openPopup();

  setTimeout(() => {
    const btn = document.getElementById('exportNearbyBtn');
    if (btn) btn.addEventListener('click', () => exportNearbyCSV(nearby, site.name));
  }, 200);
}

/* ================ Nearby export ================ */
function exportNearbyCSV(nearby, prefix){
  if (!nearby || !nearby.length) { alert('No nearby to export'); return; }
  let csv = 'name,lat,lng,distance_km,density,circle\n';
  nearby.forEach(n => csv += `${n.site.name},${n.site.lat},${n.site.lng},${(n.dist/1000).toFixed(3)},${n.site.density||''},${n.site.circle||''}\n`);
  const blob = new Blob([csv], { type:'text/csv' });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `nearby_${prefix.replace(/[^\w\-]/g,'_')}.csv`; document.body.appendChild(a); a.click(); a.remove();
}

/* ================ Highlight from place search (and map click will reuse this) ================ */
function highlightNearbyAt(lat, lon, label){
  // This function intentionally mirrors site-click highlight behavior, and is used by place search and map clicks.
  linesLayer.clearLayers();
  activeCenter = null;

  const R = Number(document.getElementById('radiusSlider').value || 1000);
  document.getElementById('radiusValue').textContent = R + ' m';

  const allChecked = document.getElementById('allCircles') ? document.getElementById('allCircles').checked : false;
  const visibleCount = document.querySelectorAll('#circleFilterBox input[type=checkbox][data-circle]:checked').length;

  const nearby = [];
  siteData.forEach(s => {
    if (!allChecked) {
      if (visibleCount === 0) return;
      const cb = document.querySelector(`#circleFilterBox input[data-circle="${s.circle}"]`);
      if (!cb || !cb.checked) return;
    }
    const d = distMeters(lat, lon, s.lat, s.lng);
    if (d <= R) nearby.push({ site: s, dist: Math.round(d) });
  });

  // Reset icons for visible markers; color nearby green
  Object.values(markers).forEach(obj => {
    const shouldShow = allChecked ? true : (document.querySelector(`#circleFilterBox input[data-circle="${obj.site.circle}"]`) && document.querySelector(`#circleFilterBox input[data-circle="${obj.site.circle}"]`).checked);
    if (!shouldShow) return;
    const found = nearby.find(n => n.site.name.toLowerCase() === obj.site.name.toLowerCase());
    if (found) obj.marker.setIcon(createDotIcon('#16a34a'));
    else obj.marker.setIcon(createDotIcon(defaultColor()));
  });

  // Draw lines + distance labels
  nearby.forEach(n => {
    L.polyline([[lat, lon],[n.site.lat, n.site.lng]], { color:'#ff7f50', weight:2 }).addTo(linesLayer);
    const midLat = (lat + n.site.lat)/2, midLng = (lon + n.site.lng)/2;
    L.marker([midLat, midLng], { icon: L.divIcon({ className:'distance-label', html: `${Math.round(n.dist)} m`, iconSize:[80,20] }) }).addTo(linesLayer);
  });

  // Popup content & show at location
  const count = nearby.length;
  let listHtml = '<div style="max-height:200px;overflow:auto;">';
  if (!count) listHtml += `<i>No sites within ${R} m</i>`; else listHtml += nearby.map(n => `${n.site.name} — ${(n.dist/1000).toFixed(3)} km — density:${n.site.density || 'N/A'}`).join('<br>');
  listHtml += '</div>';

  const popupHtml = `<div style="min-width:260px"><strong>${label}</strong><br/>Lat:${lat.toFixed(6)}, Lng:${lon.toFixed(6)}<br/><b>Count:</b> ${count}<hr/>${listHtml}<div style="margin-top:8px"><button id="exportPlaceBtn" style="padding:8px 10px;border-radius:6px;border:none;background:#0b69ff;color:#fff;cursor:pointer">Export Nearby</button></div></div>`;
  L.popup({ maxWidth:420 }).setLatLng([lat, lon]).setContent(popupHtml).openOn(map);

  setTimeout(() => {
    const b = document.getElementById('exportPlaceBtn');
    if (b) b.addEventListener('click', () => exportNearbyCSV(nearby, 'map_click'));
  }, 200);
}

/* ================ Create Dot Icon (for markers color change) ================ */
function createDotIcon(color){
  const html = `<div style="width:14px;height:14px;border-radius:50%;background:${color};box-shadow:0 2px 4px rgba(0,0,0,0.3)"></div>`;
  return L.divIcon({ html, className: '', iconSize:[14,14], iconAnchor:[7,7] });
}

/* ================ Site search (right panel) ================ */
const siteInput = document.getElementById('siteSearch');
const siteSuggest = document.getElementById('siteSuggest');

function buildSiteIndexForAutocomplete(){
  siteSuggest.innerHTML = '';
}

siteInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    const q = siteInput.value.trim().toLowerCase();
    if (!q) return;
    const match = siteData.find(s => s.name.toString().toLowerCase().includes(q));
    if (match) {
      map.setView([match.lat, match.lng], 15);
      const obj = markers[match.name.toLowerCase()];
      if (obj) { obj.marker.openPopup(); showSitePopupAndHighlight(match, obj.marker); }
    } else alert('Site not found');
  }
});
siteInput.addEventListener('input', () => {
  const q = siteInput.value.trim().toLowerCase();
  if (!q) { siteSuggest.style.display = 'none'; Object.values(markers).forEach(obj => { obj.marker.setOpacity(1); }); return; }

  const matches = siteData.filter(s => s.name.toLowerCase().includes(q)).slice(0, 20);
  siteSuggest.innerHTML = '';
  if (!matches.length) { siteSuggest.style.display = 'none'; return; }
  matches.forEach(m => {
    const div = document.createElement('div'); div.className = 'site-item'; div.textContent = m.name;
    div.addEventListener('click', () => {
      siteInput.value = m.name;
      siteSuggest.style.display = 'none';
      map.setView([m.lat, m.lng], 15);
      const obj = markers[m.name.toLowerCase()];
      if (obj) { obj.marker.openPopup(); showSitePopupAndHighlight(m, obj.marker); }
    });
    siteSuggest.appendChild(div);
  });
  siteSuggest.style.display = 'block';
});

/* close site suggestions when clicking outside */
document.addEventListener('click', (ev) => {
  if (!document.getElementById('controlPanel').contains(ev.target)) {
    siteSuggest.style.display = 'none';
  }
});

/* ================ Global place search (Nominatim) + autocomplete ================ */
const placeInput = document.getElementById('globalSearch');
const placeSuggestList = document.getElementById('placeSuggestList');

let placeDebounceTimer = null;
placeInput.addEventListener('input', (e) => {
  const q = placeInput.value.trim();
  if (!q) { placeSuggestList.style.display = 'none'; return; }
  if (placeDebounceTimer) clearTimeout(placeDebounceTimer);
  placeDebounceTimer = setTimeout(() => fetchPlaceSuggestions(q), 300);
});

async function fetchPlaceSuggestions(q){
  try {
    const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&limit=8&addressdetails=0`);
    const arr = await res.json();
    placeSuggestList.innerHTML = '';
    if (!arr || !arr.length) { placeSuggestList.style.display = 'none'; return; }
    arr.forEach(item => {
      const div = document.createElement('div'); div.className = 'autocomplete-item';
      div.textContent = item.display_name;
      div.addEventListener('click', () => {
        placeInput.value = item.display_name;
        placeSuggestList.style.display = 'none';
        const lat = parseFloat(item.lat), lon = parseFloat(item.lon);
        if (placeMarker) { try { map.removeLayer(placeMarker); } catch(e){} }
        placeMarker = L.marker([lat, lon], { title: item.display_name }).addTo(map);
        map.setView([lat, lon], 14);
        highlightNearbyAt(lat, lon, item.display_name);
      });
      placeSuggestList.appendChild(div);
    });
    placeSuggestList.style.display = 'block';
  } catch (err) {
    console.error('Place autocomplete failed', err);
    placeSuggestList.style.display = 'none';
  }
}

document.getElementById('globalSearchBtn').addEventListener('click', () => {
  const q = placeInput.value.trim();
  if (q) doGlobalSearch(q);
});
placeInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    const q = placeInput.value.trim();
    if (q) doGlobalSearch(q);
  }
});

async function doGlobalSearch(q){
  try {
    const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
    const arr = await res.json();
    if (!arr || !arr.length) { alert('Place not found'); return; }
    const best = arr[0];
    const lat = parseFloat(best.lat), lon = parseFloat(best.lon);
    if (placeMarker) { try { map.removeLayer(placeMarker); } catch(e){} }
    placeMarker = L.marker([lat, lon], { title: best.display_name }).addTo(map);
    map.setView([lat, lon], 14);
    highlightNearbyAt(lat, lon, best.display_name);
  } catch(err) { console.error(err); alert('Place search failed'); }
}

/* ================ Export visible (filtered) ================ */
document.getElementById('exportBtn').addEventListener('click', () => {
  const allChecked = document.getElementById('allCircles') ? document.getElementById('allCircles').checked : false;
  const visibleRows = siteData.filter(s => {
    if (allChecked) return true;
    const cb = document.querySelector(`#circleFilterBox input[data-circle="${s.circle}"]`);
    return cb && cb.checked;
  });
  if (!visibleRows.length) { alert('No visible rows to export'); return; }
  let csv = 'name,lat,lng,density,circle\n';
  visibleRows.forEach(r => csv += `${r.name},${r.lat},${r.lng},${r.density||''},${r.circle||''}\n`);
  const blob = new Blob([csv], { type:'text/csv' });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'visible_sites.csv'; document.body.appendChild(a); a.click(); a.remove();
});

/* ================ Radius slider live update ================ */
const radiusSlider = document.getElementById('radiusSlider');
radiusSlider.addEventListener('input', () => {
  document.getElementById('radiusValue').textContent = radiusSlider.value + ' m';
  if (activeCenter) {
    const obj = markers[activeCenter.name.toLowerCase()];
    if (obj) showSitePopupAndHighlight(activeCenter, obj.marker);
  } else if (placeMarker) {
    const p = placeMarker.getLatLng();
    highlightNearbyAt(p.lat, p.lng, placeMarker.options.title || 'Search location');
  } else if (clickMarker) {
    const p = clickMarker.getLatLng();
    highlightNearbyAt(p.lat, p.lng, `Lat:${p.lat.toFixed(6)}, Lng:${p.lng.toFixed(6)}`);
  }
});

/* ================ Upload binding & helpers ================ */
document.getElementById('csvUpload').addEventListener('change', (e) => { loadCsv(e); });
document.getElementById('loadDefaultBtn').addEventListener('click', () => { loadCsv(); });

/* helpful select all / clear all bindings */
document.getElementById('selectAllBtn').addEventListener('click', () => {
  document.querySelectorAll('#circleFilterBox input[type=checkbox][data-circle]').forEach(cb => cb.checked = true);
  const allCb = document.getElementById('allCircles'); if (allCb) allCb.checked = true;
  syncSelectedCircles();
});
document.getElementById('clearAllBtn').addEventListener('click', () => {
  document.querySelectorAll('#circleFilterBox input[type=checkbox][data-circle]').forEach(cb => cb.checked = false);
  const allCb = document.getElementById('allCircles'); if (allCb) allCb.checked = false;
  syncSelectedCircles();
});

/* close place suggestions when clicking outside */
document.addEventListener('click', (ev) => {
  if (!document.getElementById('globalSearchWrap').contains(ev.target)) {
    placeSuggestList.style.display = 'none';
  }
});

/* ================ Startup ================ */
initMap();
loadCsv();

</script>
</body>
</html>
